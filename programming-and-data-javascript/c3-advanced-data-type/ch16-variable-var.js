/* =====16. 변수, 그땐 그랬지===== */

/**
 * JavaScript는 변수를 선언하는 방식이 let이나 const가 아니라
 * variable의 약자를 따서 "var"라는 키워드로 변수를 선언할 때가 있었습니다.
 *
 * 하지만 이제는 거의 사용되지 않는데, 이유가 무엇인지 알아봅시다.
 */

/**
 * ## 문제1. 중복 선언 가능
 * 똑같은 이름으로 변수를 선언하면, Error가 발생하는 것이 아니라 기존의 변수를 덮어버립니다.
 * 
 * 당연히 let 키워드로 선언한 변수에 값을 재할당하는 것과는 다릅니다.
 * 
 * 이렇게 변수가 중복 선언이 되면, 길고 복잡한 코드를 작성할 때 실수할 가능성이 커지고,
   상황에 따라 치명적인 Error가 발생할 수 있습니다.
 */
var names = '청아';
console.log(names); // 청아
var names = '혜정';
console.log(names); // 혜정

/**
 * ## 문제2. 함수 scope
 * let과 const 키워드로 선언한 변수는 if, for, function 등등 어떤 키워드와 관계없이
 * 코드 블록(중괄호{})으로 감싸진 부분을 기준으로 scope를 갖게 되지만,
 * "var" 키워드로 선언한 변수는 scope가 function에서만 구분이 되어 있습니다.
 *
 * 그러므로 var 변수는 로컬 변수의 구분이 function에만 있기 때문에 다양한 상황(if, switch 등등)에서
 * 선언한 변수가 자칫하면 글로벌 변수의 역할을 하게 될 수 있습니다.
 */

/**
 * ## 문제3. Hoisting
 * "var" 변수는 함수 scope를 기준으로 선언되기 이전에도 변수에 접근할 수 있습니다.
 */
console.log(myVariable); // undefined
var myVariable;
/**
 * 변수의 선언이 끌려 올라가서 변수 선언문과 console.log문이 바뀐 것처럼 동작합니다.
 * 다행히 선언과 동시에 값을 할당하더라도, 선언문만 올려지고, 값은 원래 자리에 남게 됩니다.
 */
console.log(myVariable); // undefined
var myVariable = 2;
console.log(myVariable); // 2

/**
 * ### 주의할 점:
 * 함수를 선언할 때도 이 Hoisting이 적용된다.
 */
sayHi();

function sayHi() {
  console.log('Hi');
}
/**
 * 이러한 현상은 함수를 한 번 선언하면 어디서든 유용하게 사용할 수 있다는 장점이 있지만,
   코드 흐름에 부정적인 영향을 끼칠 수 있습니다.
 * 그래서 함수를 선언할 때는 가급적 코드 윗부분에 선언하거나, 호출을 항상 아래쪽에서 한다거나
   나름대로 규칙을 세워 코드를 작성해야 합니다.
 */
